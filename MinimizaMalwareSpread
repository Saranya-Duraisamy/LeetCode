Question: https://leetcode.com/problems/minimize-malware-spread/
class Solution {
    public void getNeighbours(int[][] graph, HashMap<Integer, List<Integer>> neighbors){
        int num_nodes = graph.length;
        for(int i=0; i<num_nodes; i++) {
            List<Integer> directNeighbor = new ArrayList<>();
            for(int j=0; j<num_nodes; j++){
                if(i!=j && graph[i][j] == 1){
                    directNeighbor.add(j);
                }
            }
            if(!directNeighbor.isEmpty()){
                neighbors.put(i, directNeighbor);
            }
        }
    }
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int remove_node = -1; //#remove node index(get smallest index)
        int remove_node_conn = -1; //#directly connected nodes
        int cur_node;
        int cur_node_conn;
        HashMap<Integer, List<Integer>> neighbors = new HashMap<>();
        getNeighbours(graph, neighbors);
        
        List<Integer> initialList = new ArrayList<Integer>(initial.length);
        for(int i=0; i<initial.length; i++){ // For each infected node
            initialList.add(initial[i]);
        }
        
        Queue<Integer> queue = new LinkedList<Integer>();
        while(!initialList.isEmpty()) {    
            cur_node = initialList.remove(0); // remove first node from list
            cur_node_conn = 0;

            boolean[] visited = new boolean[graph.length];
            
            if(neighbors.containsKey(cur_node)){
                for(Integer neighbor:neighbors.get(cur_node)){
                    if(visited[neighbor] == false){
                        queue.add(neighbor);
                        cur_node_conn++;
                        visited[neighbor] = true;
                    }
                }
            }
            while(!queue.isEmpty()) {
                Integer node = queue.remove();
                if(neighbors.containsKey(node)){
                    for(Integer neighbor:neighbors.get(node)) {
                        if(visited[neighbor] == false) {
                            queue.add(neighbor);
                            cur_node_conn++;
                            visited[neighbor] = true;
                        }
                    }
                }
                if(initialList.contains(node)) {
                    initialList.remove(node);
                    if(node < cur_node) {
                        cur_node = node;
                    }
                }
            }
            
            
            if(remove_node_conn < cur_node_conn) {
                remove_node_conn = cur_node_conn;
                remove_node = cur_node;
            }
            else {
                if((remove_node_conn == cur_node_conn) && (cur_node<remove_node)){
                    remove_node = cur_node;
                }
            }
        }
        return remove_node;
    }
}
